package bbhash_test

import (
	"cmp"
	"flag"
	"fmt"
	"go/format"
	"maps"
	"os"
	"slices"
	"strings"
	"testing"

	"github.com/relab/bbhash"
	"github.com/relab/bbhash/internal/test"
)

var update = flag.Bool("update", false, "update bit vectors golden test file")

// To update the bit vectors golden test file, run:
//
//	% go test -run TestReproducibleBitVectors -update
func TestReproducibleBitVectors(t *testing.T) {
	sizes := []int{
		1000,
		10000,
	}
	tests := []struct {
		name       string
		opts       []bbhash.Options
		gamma      float64
		partitions int
	}{
		{name: "sequential", gamma: 2.0, opts: []bbhash.Options{bbhash.Gamma(2.0)}},
		{name: "parallel", gamma: 2.0, opts: []bbhash.Options{bbhash.Gamma(2.0), bbhash.Parallel()}},
		{name: "partitions", gamma: 2.0, partitions: 2, opts: []bbhash.Options{bbhash.Gamma(2.0), bbhash.Partitions(2)}},
		{name: "partitions", gamma: 2.0, partitions: 4, opts: []bbhash.Options{bbhash.Gamma(2.0), bbhash.Partitions(4)}},
	}

	bvg := newBitVectorGenerator()
	for _, tt := range tests {
		for _, size := range sizes {
			partitions := cmp.Or(tt.partitions, 1)
			keys := generateKeys(size, 123)
			t.Run(test.Name(tt.name, []string{"gamma", "keys", "partitions"}, tt.gamma, size, partitions), func(t *testing.T) {
				bb, err := bbhash.New(keys, tt.opts...)
				if err != nil {
					t.Fatal(err)
				}

				if *update {
					bitVectorVarName := bvg.createBitVectorMap(size, partitions)
					bvg.createBitVectors(bitVectorVarName, bb)
				}

				want := bitVectorMap[size][partitions]
				got := bb.LevelVectors()
				if diff := diff(want, got); diff != "" {
					t.Errorf("bit vectors mismatch (-want +got):\n%s", diff)
				}
				validateKeyMappings(t, bb, keys)
			})
		}
	}
	if *update {
		testFile := "bbhash_reproducible_bit_vectors_test.go"
		t.Logf("rewriting %s", testFile)
		bvg.finalize()
		s, err := format.Source([]byte(bvg.String()))
		if err != nil {
			t.Fatal(err)
		}
		if err := os.WriteFile(testFile, s, 0o666); err != nil {
			t.Fatal(err)
		}
	}
}

type bvGenerator struct {
	bitVectorSize      map[int]string
	bitVectorPartition map[int]map[int]string
	usedVarNames       map[string]bool
	bitVectors         strings.Builder
	bitVectorsMap      strings.Builder
}

func newBitVectorGenerator() *bvGenerator {
	bvg := &bvGenerator{
		bitVectorSize:      make(map[int]string),
		bitVectorPartition: make(map[int]map[int]string),
		usedVarNames:       make(map[string]bool),
	}
	// Initialize the bit vector map builder
	bvg.bitVectorsMap.WriteString("// Code generated by bbhash_reproducible_test.go; DO NOT EDIT.\n")
	bvg.bitVectorsMap.WriteString("// This file was generated by running 'go test -run TestReproducibleBitVectors -update'.\n")
	bvg.bitVectorsMap.WriteString("// This is the golden file for the reproducible bit vectors test.\n")
	bvg.bitVectorsMap.WriteString("package bbhash_test\n\n")
	bvg.bitVectorsMap.WriteString("// bitVectorMap maps from size and partitions to their corresponding bit vectors.\n")
	bvg.bitVectorsMap.WriteString("var bitVectorMap = map[int]map[int][][][]uint64{\n")
	return bvg
}

// createBitVectorMap creates an entry for the given size and partitions in the bit vector map.
func (bvg *bvGenerator) createBitVectorMap(size, partitions int) string {
	if _, ok := bvg.bitVectorSize[size]; !ok {
		// Add the size key only once
		bvg.bitVectorSize[size] = fmt.Sprintf("%d: {\n", size)
	}
	bitVectorVarName := varName(size, partitions)

	if _, ok := bvg.bitVectorPartition[size]; !ok {
		bvg.bitVectorPartition[size] = make(map[int]string)
	}
	if _, ok := bvg.bitVectorPartition[size][partitions]; !ok {
		// Add the partitions key only once
		bvg.bitVectorPartition[size][partitions] = fmt.Sprintf("%d: %s,\n", partitions, bitVectorVarName)
	}
	return bitVectorVarName
}

// createBitVectors creates a Go string representation of the bit vectors for the given BBHash.
func (bvg *bvGenerator) createBitVectors(bitVectorVarName string, bb *bbhash.BBHash2) {
	if bvg.usedVarNames[bitVectorVarName] {
		return // Bit vectors already added for this size and partitions
	}
	bvg.usedVarNames[bitVectorVarName] = true
	// Append bit vector data only once per size
	bvg.bitVectors.WriteString(bb.BitVectors(bitVectorVarName))
	bvg.bitVectors.WriteString("\n")
}

func varName(size, partitions int) string {
	if partitions >= 2 {
		return fmt.Sprintf("bit_vectors_partitions_%d_keys_%d_partitions", size, partitions)
	}
	return fmt.Sprintf("bit_vectors_bbhash_%d_keys", size)
}

func (bvg *bvGenerator) finalize() {
	for _, size := range slices.Sorted(maps.Keys(bvg.bitVectorSize)) {
		bvg.bitVectorsMap.WriteString(bvg.bitVectorSize[size])
		if partitions, ok := bvg.bitVectorPartition[size]; ok {
			for _, partition := range slices.Sorted(maps.Keys(partitions)) {
				bvg.bitVectorsMap.WriteString(bvg.bitVectorPartition[size][partition])
			}
		}
		// Close the partition entries
		bvg.bitVectorsMap.WriteString("},\n")
	}
	// Close the top-level map structure
	bvg.bitVectorsMap.WriteString("}\n\n")
}

func (bvg *bvGenerator) String() string {
	return bvg.bitVectorsMap.String() + bvg.bitVectors.String()
}

// diff returns a custom diff of two slices of slices of uint64;
// -a is the wanted value, +b is the got value.
func diff(a, b [][][]uint64) string {
	var s strings.Builder
	minPartitions := min(len(a), len(b))
	if len(a) != len(b) {
		s.WriteString(fmt.Sprintf("partitions: a=%d, b=%d, min=%d\n", len(a), len(b), minPartitions))
	}
	for partition := 0; partition < minPartitions; partition++ {
		minLevels := min(len(a[partition]), len(b[partition]))
		if len(a[partition]) != len(b[partition]) {
			s.WriteString(fmt.Sprintf("levels: a[%d]=%d, b[%d]=%d, min=%d\n",
				partition, len(a[partition]), partition, len(b[partition]), minLevels))
		}
		for level := 0; level < minLevels; level++ {
			minEntries := min(len(a[partition][level]), len(b[partition][level]))
			if len(a[partition][level]) != len(b[partition][level]) {
				s.WriteString(fmt.Sprintf("entries: a[%d,%d]=%d, b[%d,%d]=%d, min=%d\n",
					partition, level, len(a[partition][level]), partition, level, len(b[partition][level]), minEntries))
			}
			for entry := 0; entry < minEntries; entry++ {
				w := a[partition][level][entry]
				g := b[partition][level][entry]
				if w != g {
					xor := w ^ g
					s.WriteString(fmt.Sprintf("-a[%02d,%02d,%02d]: %#016x xor: %064b\n", partition, level, entry, w, xor))
					s.WriteString(fmt.Sprintf("+b[%02d,%02d,%02d]: %#016x xor: %064b\n", partition, level, entry, g, xor))
				}
			}
		}
	}
	return s.String()
}
